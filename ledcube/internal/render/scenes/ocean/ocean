package ocean

import (
	"math"

	"github.com/coreman2200/funtimes-arcaluminis/ledcube/internal/render"
)

type Renderer struct {
	name, preset string

	// persistent sim state (XZ footprint)
	H    []float64 // height
	V    []float64 // velocity
	X, Z int

	// time book-keeping (optional)
	prevT float64
	initd bool
}

func New(name string) *Renderer {
	return &Renderer{name: name, preset: "CalmDawn"}
}

func (r *Renderer) Name() string { return r.name }
func (r *Renderer) Presets() []string {
	return []string{"CalmDawn", "SunnyDay", "Sunset", "NightStorm"}
}

func (r *Renderer) ApplyPreset(p string, u *render.Uniforms) error {
	r.preset = p
	if u == nil {
		return nil
	}
	// sensible defaults per preset
	switch p {
	case "CalmDawn":
		ensure(u, map[string]float64{
			"TideAmp": 0.2, "TidePeriodS": 120.0, "WaveSpeed": 0.9, "Damping": 0.015, "Wind": 0.05,
			"Foaminess": 0.15, "Choppiness": 0.35, "SkySat": 0.9, "DayPeriodS": 240.0, "Storminess": 0.0,
			"WaterHue": 0.58, "WaterAbsorb": 0.20, "BaseIntensity": 1.0, "PreviewGamma": 1.6,
		})
	case "SunnyDay":
		ensure(u, map[string]float64{
			"TideAmp": 0.25, "TidePeriodS": 180.0, "WaveSpeed": 1.2, "Damping": 0.01, "Wind": 0.1,
			"Foaminess": 0.18, "Choppiness": 0.5, "SkySat": 1.0, "DayPeriodS": 240.0, "Storminess": 0.0,
			"WaterHue": 0.55, "WaterAbsorb": 0.15, "BaseIntensity": 1.1, "PreviewGamma": 1.6,
		})
	case "Sunset":
		ensure(u, map[string]float64{
			"TideAmp": 0.22, "TidePeriodS": 180.0, "WaveSpeed": 1.0, "Damping": 0.012, "Wind": 0.08,
			"Foaminess": 0.14, "Choppiness": 0.45, "SkySat": 1.1, "DayPeriodS": 240.0, "Storminess": 0.0,
			"WaterHue": 0.53, "WaterAbsorb": 0.18, "BaseIntensity": 1.0, "PreviewGamma": 1.7,
		})
	case "NightStorm":
		ensure(u, map[string]float64{
			"TideAmp": 0.3, "TidePeriodS": 150.0, "WaveSpeed": 1.3, "Damping": 0.02, "Wind": 0.35,
			"Foaminess": 0.30, "Choppiness": 0.8, "SkySat": 0.7, "DayPeriodS": 240.0, "Storminess": 0.8,
			"LightningRate": 0.15, "WaterHue": 0.60, "WaterAbsorb": 0.25, "BaseIntensity": 1.0, "PreviewGamma": 1.6,
		})
	}
	return nil
}

func (r *Renderer) Params() map[string]float64 {
	return map[string]float64{
		"TideAmp": 0.22, "TidePeriodS": 180, "WaveSpeed": 1.1, "Damping": 0.012, "Wind": 0.08,
		"Foaminess": 0.18, "Choppiness": 0.45, "SkySat": 1.0, "DayPeriodS": 240.0, "Storminess": 0.0,
		"LightningRate": 0.0, "WaterHue": 0.56, "WaterAbsorb": 0.18, "BaseIntensity": 1.0, "PreviewGamma": 1.6,
		// orientation helpers if needed
		"FlipX": 0, "FlipZ": 1,
	}
}

// ---- render entrypoint ----
func (r *Renderer) Render(dst []render.Color, _ []render.Vec3, dim render.Dimensions, t float64, u *render.Uniforms, _ *render.Resources) {
	X, Y, Z := int(dim.X), int(dim.Y), int(dim.Z)
	if len(dst) < X*Y*Z {
		return
	}

	// ensure state
	if !r.initd || r.X != X || r.Z != Z {
		r.X, r.Z = X, Z
		r.H = make([]float64, X*Z)
		r.V = make([]float64, X*Z)
		seedHeights(r.H, X, Z)
		r.prevT = t
		r.initd = true
	}

	// params
	tideAmp := pget(u, "TideAmp", 0.22)
	tidePeriod := pget(u, "TidePeriodS", 180.0)
	waveSpeed := pget(u, "WaveSpeed", 1.1)
	damping := pget(u, "Damping", 0.012)
	wind := pget(u, "Wind", 0.08)
	foaminess := pget(u, "Foaminess", 0.18)
	choppy := pget(u, "Choppiness", 0.45)
	skySat := pget(u, "SkySat", 1.0)
	dayPeriod := pget(u, "DayPeriodS", 240.0)
	storminess := pget(u, "Storminess", 0.0)
	lightRate := pget(u, "LightningRate", 0.0)
	waterHue := pget(u, "WaterHue", 0.56)
	absorb := pget(u, "WaterAbsorb", 0.18)
	baseI := pget(u, "BaseIntensity", 1.0)
	prevGamma := pget(u, "PreviewGamma", 1.6)
	flipX := pget(u, "FlipX", 0) > 0.5
	flipZ := pget(u, "FlipZ", 1) > 0.5

	// integrate sim (small fixed dt; use t for phase drift)
	dt := clamp(r.prevT, 0, 1e9)
	_ = dt
	// fixed timestep ~16ms for stability, decoupled from host t
	r.stepSim(0.016, waveSpeed, damping, wind, choppy)

	// tide height (0..1 of Y-1 range), centered mid-height
	tide := tideAmp * math.Sin(2*math.Pi*t/tidePeriod)
	baseLevel := 0.45 + tide // 0..1 scale

	// sun angle for sky gradient
	dayPhase := math.Mod(t/dayPeriod, 1.0)
	sunElev := math.Sin(2 * math.Pi * dayPhase) // -1..1

	// lightning flash
	flash := 0.0
	if storminess > 0 && lightRate > 0 {
		// cheap pseudo-random flash envelope
		p := fract(math.Sin(t*13.37) * 43758.5453)
		if p < lightRate*0.02 {
			flash = 1.0
		}
	}

	// draw columns
	i := 0
	for z := 0; z < Z; z++ {
		for y := 0; y < Y; y++ {
			for x := 0; x < X; x++ {
				// visual axis flips (don’t change linear order)
				vx := x
				vz := z
				if flipX {
					vx = (X - 1) - vx
				}
				if flipZ {
					vz = (Z - 1) - vz
				}

				// surface height (0..Y-1)
				h := r.surfaceHeight(vx, vz, baseLevel, float64(Y))

				if float64(y) <= h {
					// WATER voxel
					depthN := clamp((h-float64(y))/4.0, 0, 1) // attenuate with depth near surface
					// blue from hue + subtle green
					R, G, B := hsv(waterHue, 0.85, 0.9)
					// absorption in depth
					G *= (1.0 - absorb*0.5*depthN)
					R *= (1.0 - absorb*0.8*depthN)
					// surface highlight near h
					nearSurf := clamp(1.0-math.Abs(float64(y)-h), 0, 1)
					spec := 0.25 * nearSurf * clamp(0.2+0.8*sunElev, 0, 1)
					R = clamp(R+spec, 0, 1)
					G = clamp(G+spec, 0, 1)
					B = clamp(B+spec, 0, 1)
					// foam if steep/fast
					if r.foamy(vx, vz, foaminess) && nearSurf > 0.5 {
						R = clamp(R+0.8*nearSurf, 0, 1)
						G = clamp(G+0.8*nearSurf, 0, 1)
						B = clamp(B+0.8*nearSurf, 0, 1)
					}
					apply(dst[i:], R, G, B, baseI, prevGamma)
				} else {
					// SKY voxel
					yn := float64(y) / float64(Y-1) // 0..1 bottom→top
					R, G, B := skyGradient(yn, sunElev, skySat)
					// storm flash lifts sky
					if flash > 0 {
						R = clamp(R+flash, 0, 1)
						G = clamp(G+flash, 0, 1)
						B = clamp(B+flash, 0, 1)
					}
					apply(dst[i:], R, G, B, baseI, prevGamma)
				}
				i++
			}
		}
	}

	r.prevT = t
}

// ---- sim + color helpers ----

func (r *Renderer) idx(x, z int) int { return z*r.X + x }

func (r *Renderer) stepSim(dt, c, damping, wind, choppy float64) {
	if r.X*r.Z == 0 {
		return
	}
	X, Z := r.X, r.Z

	// discrete laplacian on H → accelerates V
	for z := 0; z < Z; z++ {
		for x := 0; x < X; x++ {
			i := r.idx(x, z)
			// neighbors with clamped boundaries (reflect)
			hc := r.H[i]
			hl := r.H[r.idx(clampi(x-1, 0, X-1), z)]
			hr := r.H[r.idx(clampi(x+1, 0, X-1), z)]
			hd := r.H[r.idx(x, clampi(z-1, 0, Z-1))]
			hu := r.H[r.idx(x, clampi(z+1, 0, Z-1))]
			lap := (hl + hr + hd + hu - 4.0*hc)

			acc := c * c * lap
			r.V[i] += acc * dt
			r.V[i] *= (1.0 - damping)
		}
	}
	// add a little wind/chop (moving phase)
	phase := func(x, z int) float64 { return math.Sin(0.11*float64(x) + 0.13*float64(z) + 1.7*float64(choppy)) }
	for z := 0; z < Z; z++ {
		for x := 0; x < X; x++ {
			i := r.idx(x, z)
			r.V[i] += wind * 0.02 * phase(x, z)
		}
	}
	// integrate height
	for i := 0; i < X*Z; i++ {
		r.H[i] += r.V[i] * dt
	}
}

func (r *Renderer) surfaceHeight(x, z int, baseLevel float64, yMax float64) float64 {
	// baseLevel is 0..~1, H adds small +/- (scale)
	h := baseLevel + 0.10*r.H[r.idx(x, z)]
	return clamp(h*(yMax-1), 0, yMax-1)
}

func (r *Renderer) slope(x, z int) float64 {
	X, Z := r.X, r.Z
	i := r.idx(x, z)
	hl := r.H[r.idx(clampi(x-1, 0, X-1), z)]
	hr := r.H[r.idx(clampi(x+1, 0, X-1), z)]
	hd := r.H[r.idx(x, clampi(z-1, 0, Z-1))]
	hu := r.H[r.idx(x, clampi(z+1, 0, Z-1))]
	return math.Abs(hr-hl) + math.Abs(hu-hd)
}

func (r *Renderer) foamy(x, z int, foaminess float64) bool {
	s := r.slope(x, z)
	v := math.Abs(r.V[r.idx(x, z)])
	return s+v > (0.15 + 0.8*(1.0-foaminess)) // more foam when foaminess↑
}

// color utilities
func hsv(h, s, v float64) (float64, float64, float64) {
	h = h - math.Floor(h) // 0..1
	i := int(h * 6)
	f := h*6 - float64(i)
	p := v * (1 - s)
	q := v * (1 - f*s)
	t := v * (1 - (1-f)*s)
	switch i % 6 {
	case 0:
		return v, t, p
	case 1:
		return q, v, p
	case 2:
		return p, v, t
	case 3:
		return p, q, v
	case 4:
		return t, p, v
	default:
		return v, p, q
	}
}

func skyGradient(y, sunElev, sat float64) (float64, float64, float64) {
	// simple 4-stop gradient that shifts with sun elevation
	// base colors
	bottom := mix3(0.95, 0.55, 0.25, 0.1, 0.2, 0.4, clamp01((sunElev+0.2)*0.5)) // warm sunrise→cool night
	top := mix3(0.6, 0.8, 1.0, 0.02, 0.05, 0.1, clamp01((sunElev+0.4)*0.5))
	// vertical mix
	R := bottom[0]*(1-y) + top[0]*y
	G := bottom[1]*(1-y) + top[1]*y
	B := bottom[2]*(1-y) + top[2]*y
	// saturation
	l := 0.2126*R + 0.7152*G + 0.0722*B
	R = l + (R-l)*sat
	G = l + (G-l)*sat
	B = l + (B-l)*sat
	return clamp(R, 0, 1), clamp(G, 0, 1), clamp(B, 0, 1)
}

func mix3(r1, g1, b1, r2, g2, b2, t float64) [3]float64 {
	return [3]float64{
		r1 + (r2-r1)*t, g1 + (g2-g1)*t, b1 + (b2-b1)*t,
	}
}

func apply(dst []render.Color, R, G, B, baseI, gamma float64) {
	// preview lift + gamma; engine post will still apply Filmic if enabled
	R = math.Pow(clamp(R*baseI, 0, 1), 1.0/math.Max(1e-6, gamma))
	G = math.Pow(clamp(G*baseI, 0, 1), 1.0/math.Max(1e-6, gamma))
	B = math.Pow(clamp(B*baseI, 0, 1), 1.0/math.Max(1e-6, gamma))
	dst[0].R = float32(R)
	dst[0].G = float32(G)
	dst[0].B = float32(B)
}

func clamp(x, a, b float64) float64 {
	if x < a {
		return a
	}
	if x > b {
		return b
	}
	return x
}
func clampi(x, a, b int) int {
	if x < a {
		return a
	}
	if x > b {
		return b
	}
	return x
}
func ensure(u *render.Uniforms, kv map[string]float64) {
	if u.Params == nil {
		u.Params = map[string]float64{}
	}
	for k, v := range kv {
		if _, ok := u.Params[k]; !ok {
			u.Params[k] = v
		}
	}
}
func fract(x float64) float64 { return x - math.Floor(x) }

// seed small bumps
func seedHeights(H []float64, X, Z int) {
	for z := 0; z < Z; z++ {
		for x := 0; x < X; x++ {
			i := z*X + x
			// low amplitude random-ish seed based on coords
			n := math.Sin(float64(37*x+57*z))*0.03 + math.Sin(float64(11*x+23*z))*0.02
			H[i] = n
		}
	}
}
